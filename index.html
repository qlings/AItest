<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Ê§çÁâ©Â§ßÊàòÂÜ∞È≠îÂ•≥</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a1a;
            color: white;
            height: 100vh;
            width: 100vw;
            margin: 0;
            padding: 0;
            user-select: none;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
        }

        #game-container {
            position: relative;
            transform-origin: center center;
            width: 960px;
            height: 600px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #ui-bar {
            background-color: #3e2723;
            border: 3px solid #5d4037;
            border-radius: 12px;
            padding: 5px 10px;
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 8px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.6);
            z-index: 10;
            width: 940px;
            box-sizing: border-box;
            justify-content: space-between;
        }

        .info-panel {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #sun-display {
            font-size: 18px;
            font-weight: bold;
            color: #ffeb3b;
            background: rgba(0,0,0,0.4);
            padding: 4px 10px;
            border-radius: 15px;
            display: flex;
            align-items: center;
            gap: 5px;
            border: 1px solid #fbc02d;
            min-width: 70px;
        }

        #level-display {
            font-size: 14px;
            color: #b3e5fc;
            white-space: nowrap;
        }

        #progress-bar-container {
            width: 100px;
            height: 8px;
            background: #444;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 2px;
        }
        #progress-bar {
            height: 100%;
            width: 0%;
            background: #76ff03;
            transition: width 0.3s;
        }

        /* Èì≤Â≠êÊßΩ‰Ωç */
        .shovel-slot {
            background-color: #5d4037;
            border: 2px solid #8d6e63;
            border-radius: 6px;
            width: 50px;
            height: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.1s;
            font-size: 28px;
            margin-right: 10px;
        }
        .shovel-slot:hover { transform: translateY(-2px); filter: brightness(1.2); }
        .shovel-slot.selected { border-color: #ffff00; box-shadow: 0 0 10px #ffff00; background-color: #795548; }

        .card-container {
            display: flex;
            gap: 6px;
            flex-grow: 1;
            justify-content: center;
        }

        .card {
            background-color: #757575;
            border: 2px solid #424242;
            border-radius: 6px;
            width: 55px;
            height: 75px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.1s;
            position: relative;
        }

        .card:hover { transform: translateY(-2px); }
        .card:active { transform: translateY(1px); }
        .card.selected { border-color: #ffff00; box-shadow: 0 0 12px #ffff00; background-color: #9e9e9e; transform: scale(1.05); }
        .card.disabled { opacity: 0.4; cursor: not-allowed; filter: grayscale(1); }
        
        .cooldown-mask {
            position: absolute;
            bottom: 0; left: 0; width: 100%; height: 0%;
            background-color: rgba(0, 0, 0, 0.7);
            transition: height 0.1s linear;
            border-radius: 4px;
        }

        .card-icon { font-size: 26px; z-index: 2; }
        .card-cost { font-size: 11px; font-weight: bold; margin-top: 2px; color: #fff; text-shadow: 1px 1px 0 #000; z-index: 2; }

        #game-wrapper {
            position: relative;
            border: 6px solid #5d4037;
            border-radius: 4px;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
            background-color: #000;
            width: 940px;
            height: 520px;
        }

        canvas {
            display: block;
            cursor: crosshair;
            background-color: #4caf50;
            background-image: 
                linear-gradient(45deg, #43a047 25%, transparent 25%), 
                linear-gradient(-45deg, #43a047 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #43a047 75%), 
                linear-gradient(-45deg, transparent 75%, #43a047 75%);
            background-size: 100px 100px;
            background-position: 40px 0, 40px 50px, 90px -50px, -10px 0px;
            width: 100%;
            height: 100%;
        }

        .overlay-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(5px);
        }

        .level-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin: 20px 0;
            max-width: 800px;
        }

        .level-btn {
            background: #5d4037;
            border: 2px solid #8d6e63;
            color: #ffecb3;
            padding: 15px;
            font-size: 18px;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s;
            text-align: center;
        }

        .level-btn:hover { background: #795548; transform: scale(1.05); border-color: #ffeb3b; }
        .level-btn.boss-level { border-color: #f44336; background: #3e2723; color: #ff5252; }
        .level-btn.endless-level { border-color: #9c27b0; background: #311b92; color: #e040fb; grid-column: span 4; font-weight: bold; margin-top: 10px;}

        h1 { color: #f44336; font-size: 40px; margin: 0 0 10px 0; text-shadow: 3px 3px 0 #000; text-align: center; }
        h2 { color: #ffeb3b; margin-top: 0; text-shadow: 2px 2px 0 #000; text-align: center; font-size: 20px; }

        .big-btn {
            padding: 12px 30px;
            font-size: 20px;
            background: linear-gradient(to bottom, #8bc34a, #558b2f);
            color: white;
            border: 2px solid #33691e;
            border-radius: 25px;
            cursor: pointer;
            box-shadow: 0 4px 0 #1b5e20;
            transition: transform 0.1s;
            font-weight: bold;
            text-transform: uppercase;
            margin: 10px;
        }
        .big-btn:hover { filter: brightness(1.1); }
        .big-btn:active { transform: translateY(4px); box-shadow: 0 0 0 #1b5e20; }
        .secondary-btn { background: #607d8b; border-color: #455a64; box-shadow: 0 4px 0 #263238; }

        .controls-panel { display: flex; gap: 8px; margin-left: 10px; }
        .ctrl-btn {
            background-color: #558b2f; color: white; border: 2px solid #33691e; border-radius: 8px;
            padding: 5px 10px; font-size: 16px; cursor: pointer; font-weight: bold;
            transition: all 0.1s; display: flex; align-items: center; justify-content: center;
        }
        .ctrl-btn:hover { filter: brightness(1.1); }
        .ctrl-btn:active { transform: translateY(2px); }
        .ctrl-btn.paused { background-color: #fbc02d; color: #333; }

        #message {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            font-size: 40px; color: #fff; font-weight: bold;
            text-shadow: 0 0 10px #ff00de, 3px 3px 0 #000;
            pointer-events: none; opacity: 0; transition: opacity 0.5s, transform 0.5s; z-index: 50; white-space: nowrap;
        }
        
        #rotate-tip {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 9999; color: white;
            flex-direction: column; align-items: center; justify-content: center; text-align: center;
        }
    </style>
</head>
<body>

    <div id="rotate-tip"><h1>ËØ∑ÊóãËΩ¨ÊâãÊú∫</h1><p>Ê®™Â±èÊ∏∏Áé©‰ΩìÈ™åÊõ¥‰Ω≥</p></div>

    <div id="game-container">
        <div id="ui-bar">
            <div class="info-panel">
                <div class="shovel-slot" id="shovel-btn" onclick="toggleShovel()" ontouchstart="toggleShovel(); event.preventDefault()">
                    ‚õèÔ∏è
                </div>
                <div id="sun-display">‚òÄÔ∏è <span id="sun-count">150</span></div>
                <div>
                    <div id="level-display"><span id="level-name">ÊïôÂ≠¶ÂÖ≥</span></div>
                    <div id="progress-bar-container"><div id="progress-bar"></div></div>
                </div>
            </div>
            
            <div class="card-container">
                <div class="card" id="card-sunflower" onclick="selectPlant('sunflower')" ontouchstart="selectPlant('sunflower'); event.preventDefault()">
                    <div class="card-icon">üåª</div><div class="card-cost">50</div><div class="cooldown-mask"></div>
                </div>
                <div class="card" id="card-peashooter" onclick="selectPlant('peashooter')" ontouchstart="selectPlant('peashooter'); event.preventDefault()">
                    <div class="card-icon">üå±</div><div class="card-cost">100</div><div class="cooldown-mask"></div>
                </div>
                <div class="card" id="card-wallnut" onclick="selectPlant('wallnut')" ontouchstart="selectPlant('wallnut'); event.preventDefault()">
                    <div class="card-icon">üå∞</div><div class="card-cost">50</div><div class="cooldown-mask"></div>
                </div>
                <div class="card" id="card-snowpea" onclick="selectPlant('snowpea')" ontouchstart="selectPlant('snowpea'); event.preventDefault()">
                    <div class="card-icon">‚ùÑÔ∏è</div><div class="card-cost">175</div><div class="cooldown-mask"></div>
                </div>
                <div class="card" id="card-jalapeno" onclick="selectPlant('jalapeno')" ontouchstart="selectPlant('jalapeno'); event.preventDefault()">
                    <div class="card-icon">üå∂Ô∏è</div><div class="card-cost">125</div><div class="cooldown-mask"></div>
                </div>
                <div class="card" id="card-cherrybomb" onclick="selectPlant('cherrybomb')" ontouchstart="selectPlant('cherrybomb'); event.preventDefault()">
                    <div class="card-icon">üçí</div><div class="card-cost">150</div><div class="cooldown-mask"></div>
                </div>
            </div>
            
            <div class="controls-panel">
                <button class="ctrl-btn" id="btn-sound" onclick="SoundManager.toggleMute()" ontouchstart="SoundManager.toggleMute(); event.preventDefault()">üîä</button>
                <button class="ctrl-btn" id="btn-menu" onclick="toggleLevelMenu()" style="background-color: #795548;" ontouchstart="toggleLevelMenu(); event.preventDefault()">‚ò∞</button>
                <button class="ctrl-btn" id="btn-pause" onclick="togglePause()" ontouchstart="togglePause(); event.preventDefault()">‚è∏Ô∏è</button>
            </div>
        </div>

        <div id="game-wrapper">
            <canvas id="gameCanvas" width="940" height="520"></canvas>
            <div id="message"></div>
            
            <!-- ‰∏ªËèúÂçï/ÂÖ≥Âç°ÈÄâÊã© -->
            <div id="menu-screen" class="overlay-screen" style="display: flex;">
                <h1 style="color: #76ff03;">Ê§çÁâ©Â§ßÊàòÂÜ∞È≠îÂ•≥</h1>
                <h2>ÈÄâÊã©ÂÖ≥Âç°</h2>
                <div class="level-grid" id="level-grid">
                    <!-- Âä®ÊÄÅÁîüÊàê -->
                </div>
            </div>

            <!-- Ê∏∏ÊàèÁªìÊùü -->
            <div id="game-over-screen" class="overlay-screen">
                <h1>GAME OVER</h1>
                <h2>ËÑëÂ≠êË¢´ÂêÉÊéâ‰∫Ü...</h2>
                <div style="display:flex;">
                    <button class="big-btn" onclick="restartLevel()" ontouchstart="restartLevel(); event.preventDefault()">ÈáçËØï</button>
                    <button class="big-btn secondary-btn" onclick="showLevelMenu()" ontouchstart="showLevelMenu(); event.preventDefault()">ËèúÂçï</button>
                </div>
            </div>

            <!-- ÂÖ≥Âç°ÂÆåÊàê -->
            <div id="level-clear-screen" class="overlay-screen">
                <h1 style="color: #ffeb3b;">ÂÖ≥Âç°ÂÆåÊàê!</h1>
                <h2 id="level-clear-msg"></h2>
                <div style="display:flex;">
                    <button class="big-btn" onclick="nextLevel()" id="btn-next-level" ontouchstart="nextLevel(); event.preventDefault()">‰∏ã‰∏ÄÂÖ≥</button>
                    <button class="big-btn secondary-btn" onclick="showLevelMenu()" ontouchstart="showLevelMenu(); event.preventDefault()">ËèúÂçï</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Èü≥ÊïàÁÆ°ÁêÜÂô® (Web Audio API) ---
        const SoundManager = {
            ctx: null,
            muted: false,
            init: function() {
                if (!this.ctx) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    if (AudioContext) {
                        this.ctx = new AudioContext();
                    }
                }
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },
            toggleMute: function() {
                this.muted = !this.muted;
                const btn = document.getElementById('btn-sound');
                btn.innerHTML = this.muted ? "üîá" : "üîä";
                this.init();
            },
            play: function(type) {
                if (this.muted || !this.ctx) return;
                if (this.ctx.state === 'suspended') this.ctx.resume().catch(()=>{});

                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.connect(gain);
                gain.connect(this.ctx.destination);

                switch (type) {
                    case 'shoot': 
                        osc.type = 'triangle';
                        osc.frequency.setValueAtTime(600, t);
                        osc.frequency.exponentialRampToValueAtTime(100, t + 0.1);
                        gain.gain.setValueAtTime(0.1, t);
                        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                        osc.start(t);
                        osc.stop(t + 0.1);
                        break;
                    case 'hit': 
                        osc.type = 'square';
                        osc.frequency.setValueAtTime(150, t);
                        osc.frequency.exponentialRampToValueAtTime(50, t + 0.05);
                        gain.gain.setValueAtTime(0.05, t);
                        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.05);
                        osc.start(t);
                        osc.stop(t + 0.05);
                        break;
                    case 'sun': 
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(800, t);
                        osc.frequency.exponentialRampToValueAtTime(1200, t + 0.1);
                        gain.gain.setValueAtTime(0.1, t);
                        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
                        osc.start(t);
                        osc.stop(t + 0.2);
                        break;
                    case 'plant': 
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(200, t);
                        osc.frequency.linearRampToValueAtTime(400, t + 0.1);
                        gain.gain.setValueAtTime(0.1, t);
                        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
                        osc.start(t);
                        osc.stop(t + 0.15);
                        break;
                    case 'explode': 
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(100, t);
                        osc.frequency.exponentialRampToValueAtTime(10, t + 0.4);
                        gain.gain.setValueAtTime(0.3, t);
                        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
                        osc.start(t);
                        osc.stop(t + 0.4);
                        break;
                    case 'click': 
                        osc.type = 'triangle';
                        osc.frequency.setValueAtTime(800, t);
                        gain.gain.setValueAtTime(0.05, t);
                        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.05);
                        osc.start(t);
                        osc.stop(t + 0.05);
                        break;
                    case 'win': 
                        this.playTone(600, t, 0.1);
                        this.playTone(800, t + 0.1, 0.1);
                        this.playTone(1200, t + 0.2, 0.4);
                        break;
                    case 'lose': 
                        this.playTone(400, t, 0.2);
                        this.playTone(300, t + 0.2, 0.2);
                        this.playTone(200, t + 0.4, 0.4);
                        break;
                }
            },
            playTone: function(freq, time, duration) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.frequency.setValueAtTime(freq, time);
                gain.gain.setValueAtTime(0.1, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + duration);
                osc.start(time);
                osc.stop(time + duration);
            }
        };

        const CELL_SIZE = 100;
        const GRID_OFFSET_X = 40; 
        const GRID_ROWS = 5;
        const GRID_COLS = 9;
        const GAME_SPEED_SCALE = 0.7; 

        // --- Ê∏∏ÊàèÊï∞ÊçÆÈÖçÁΩÆ ---
        
        const ZOMBIES_INFO = {
            normal:    { hp: 100, speed: 0.3, color: '#212121', hat: null, scale: 1, damage: 20 },
            cone:      { hp: 300, speed: 0.3, color: '#ff9800', hat: 'cone', scale: 1, damage: 20 },
            bucket:    { hp: 800, speed: 0.3, color: '#bdbdbd', hat: 'bucket', scale: 1, damage: 20 },
            rusher:    { hp: 200, speed: 0.7, color: '#d32f2f', hat: 'rusher', scale: 1, damage: 30 }, 
            giant:     { hp: 1500, speed: 0.2, color: '#1a237e', hat: 'giant', scale: 1.4, damage: 9999 },
            boss:      { hp: 5000, speed: 0.1, color: '#311b92', hat: 'crown', scale: 2.0, damage: 50, isBoss: true } 
        };

        const PLANTS_INFO = {
            sunflower:  { cost: 50,  health: 300, type: 'sunflower',  icon: 'üåª', color: '#fbc02d', cooldown: 200 },
            peashooter: { cost: 100, health: 300, type: 'peashooter', icon: 'üå±', color: '#4caf50', cooldown: 100 },
            wallnut:    { cost: 50,  health: 2000, type: 'wallnut',    icon: 'üå∞', color: '#795548', cooldown: 300 },
            snowpea:    { cost: 175, health: 300, type: 'snowpea',    icon: '‚ùÑÔ∏è', color: '#29b6f6', cooldown: 100 },
            jalapeno:   { cost: 125, health: 1000, type: 'jalapeno',   icon: 'üå∂Ô∏è', color: '#f44336', cooldown: 400, instant: true, damage: 1800 },
            cherrybomb: { cost: 150, health: 1000, type: 'cherrybomb', icon: 'üçí', color: '#880e4f', cooldown: 400, instant: true, damage: 1800 }
        };

        const LEVELS = [
            { id: 1, name: "1. Êñ∞ÊâãËä±Âõ≠", goal: 10, waves: [['normal']], msg: "ÁÆÄÂçïÁöÑÂºÄÂßã" },
            { id: 2, name: "2. Ë∑ØÈöúÊù•Ë¢≠", goal: 20, waves: [['normal', 'cone']], msg: "Â∞èÂøÉË∑ØÈöúÈ≠îÂ•≥" },
            { id: 3, name: "3. ÈìÅÊ°∂Èò≤Âæ°", goal: 30, waves: [['normal', 'cone', 'bucket']], msg: "ÂùöÂõ∫ÁöÑÊïå‰∫∫" },
            { id: 4, name: "4. ÊûÅÈÄüÁ™ÅÂáª", goal: 40, waves: [['normal', 'cone', 'rusher']], msg: "Â•π‰ª¨Ë∑ëÂæóÂæàÂø´!" },
            { id: 5, name: "5. Â∑®‰∫∫ÂéãÂ¢É", goal: 30, waves: [['normal', 'bucket', 'giant']], msg: "Â∑®ÂûãÈ≠îÂ•≥Âá∫Ê≤°!" },
            { id: 6, name: "6. ÁàÜÁÇ∏Ëâ∫ÊúØ", goal: 50, waves: [['bucket', 'rusher', 'giant']], msg: "‰ΩøÁî®Ëæ£Ê§íÂíåÁÇ∏Âºπ!" },
            { id: 7, name: "7. Â•≥ÁéãÈôç‰∏¥", mode: 'boss', bossHp: 5000, waves: [['normal', 'cone', 'bucket']], msg: "ÂáªË¥•È≠îÂ•≥Â•≥Áéã!" },
            { id: 8, name: "‚àû. Êó†Â∞ΩÊ¢¶È≠á", mode: 'endless', waves: [['normal', 'cone', 'bucket', 'rusher', 'giant']], msg: "‰Ω†ËÉΩÂùöÊåÅÂ§ö‰πÖ?" }
        ];

        // --- ÂÖ®Â±ÄÂèòÈáè ---
        let canvas, ctx;
        let gameLoopId;
        let lastTime = 0;
        let globalTimer = 0; 
        
        let gameState = {
            sun: 500, 
            levelIndex: 0,
            zombiesKilled: 0,
            zombiesSpawned: 0,
            zombieSpawnTimer: 0,
            isGameOver: false,
            isLevelClear: false,
            paused: false,
            userPaused: false,
            hasStarted: false,
            currentLevelData: null,
            shovelMode: false,
            bossSpawned: false,
            score: 0 
        };

        let selectedPlant = null;
        let plants = [];
        let zombies = [];
        let projectiles = [];
        let sunItems = [];
        let particles = [];
        let mowers = [];

        let cooldowns = {};

        window.onload = function() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            canvas.addEventListener('mousedown', handleInput);
            canvas.addEventListener('touchstart', handleInput, {passive: false});
            
            // ‰øÆÂ§çÔºöÁßªÈô§‰πãÂâçÁöÑ querySelectorAll ‰ª£Á†ÅÔºåÊîπ‰∏∫Âú® HTML ‰∏≠Áõ¥Êé•ÁªëÂÆöÔºåÈò≤Ê≠¢ÂèåÈáçËß¶ÂèëÊàñ‰∏çËß¶Âèë
            // UI Button Touches handled in HTML via ontouchstart

            window.addEventListener('resize', fitToScreen);
            fitToScreen(); 
            
            generateLevelMenu();
            drawBackground();
        };

        function fitToScreen() {
            const container = document.getElementById('game-container');
            const scale = Math.min(window.innerWidth / 980, window.innerHeight / 620, 1.2); 
            container.style.transform = `scale(${scale})`;
        }

        function generateLevelMenu() {
            const grid = document.getElementById('level-grid');
            grid.innerHTML = '';
            LEVELS.forEach((lvl, index) => {
                const btn = document.createElement('div');
                btn.className = 'level-btn';
                if (lvl.mode === 'boss') btn.classList.add('boss-level');
                if (lvl.mode === 'endless') btn.classList.add('endless-level');
                btn.innerHTML = lvl.name;
                // ÂêåÊó∂ÁªëÂÆö click Âíå touchstart Á°Æ‰øùÂìçÂ∫î
                btn.onclick = () => { SoundManager.init(); startLevel(index); }; 
                btn.ontouchstart = (e) => { e.preventDefault(); SoundManager.init(); startLevel(index); };
                grid.appendChild(btn);
            });
        }

        function toggleLevelMenu() {
            SoundManager.play('click');
            SoundManager.init(); 
            const menuScreen = document.getElementById('menu-screen');
            const isMenuOpen = menuScreen.style.display === 'flex';

            if (isMenuOpen) {
                if (gameState.hasStarted && !gameState.isGameOver && !gameState.isLevelClear) {
                    menuScreen.style.display = 'none';
                    if (gameState.userPaused) {
                        gameState.paused = true;
                        drawScene();
                        ctx.fillStyle = "rgba(0,0,0,0.5)";
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.fillStyle = "white";
                        ctx.font = "60px Arial";
                        ctx.textAlign = "center";
                        ctx.fillText("Â∑≤ÊöÇÂÅú", canvas.width/2, canvas.height/2);
                    } else {
                        gameState.paused = false;
                        lastTime = performance.now();
                        gameLoop(performance.now());
                    }
                }
            } else {
                showLevelMenu();
            }
        }

        function showLevelMenu() {
            gameState.paused = true;
            document.querySelectorAll('.overlay-screen').forEach(el => el.style.display = 'none');
            document.getElementById('menu-screen').style.display = 'flex';
        }

        function startLevel(index) {
            SoundManager.play('click');
            gameState.levelIndex = index;
            const lvl = LEVELS[index];
            gameState.currentLevelData = lvl;
            
            gameState.sun = 500; 
            gameState.zombiesKilled = 0;
            gameState.zombiesSpawned = 0;
            gameState.score = 0;
            gameState.isGameOver = false;
            gameState.isLevelClear = false;
            gameState.paused = false;
            gameState.userPaused = false;
            gameState.hasStarted = true;
            gameState.bossSpawned = false;
            gameState.shovelMode = false;
            gameState.zombieSpawnTimer = 0; 
            
            lastTime = performance.now();
            globalTimer = 0;
            plants = []; zombies = []; projectiles = []; sunItems = []; particles = [];
            
            mowers = [];
            for(let i=0; i<GRID_ROWS; i++) mowers.push({ row: i, x: 0, active: false, triggered: false, angle: 0 });

            for(let key in PLANTS_INFO) cooldowns[key] = 0;

            document.querySelectorAll('.overlay-screen').forEach(el => el.style.display = 'none');
            document.getElementById('level-name').innerText = lvl.name;
            updateUI();
            
            toggleShovel(false);
            
            showMessage(lvl.msg);
            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            gameLoop(performance.now());
        }

        function restartLevel() { startLevel(gameState.levelIndex); }
        function nextLevel() {
            if (gameState.levelIndex < LEVELS.length - 1) startLevel(gameState.levelIndex + 1);
            else showLevelMenu();
        }

        function togglePause() {
            SoundManager.init();
            SoundManager.play('click');
            if (!gameState.hasStarted || gameState.isGameOver || gameState.isLevelClear) return;
            gameState.userPaused = !gameState.userPaused;
            gameState.paused = gameState.userPaused;
            const btn = document.getElementById('btn-pause');
            btn.innerHTML = gameState.paused ? "‚ñ∂Ô∏è" : "‚è∏Ô∏è";
            btn.classList.toggle('paused', gameState.paused);
            if (!gameState.paused) { lastTime = performance.now(); gameLoop(performance.now()); }
        }

        function toggleShovel(forceState) {
            if (forceState !== undefined) gameState.shovelMode = forceState;
            else {
                gameState.shovelMode = !gameState.shovelMode;
                SoundManager.play('click');
            }
            
            const btn = document.getElementById('shovel-btn');
            if(gameState.shovelMode) {
                btn.classList.add('selected');
                selectedPlant = null; highlightCard(null); 
                canvas.style.cursor = "url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\"><text y=\"20\" font-size=\"20\">‚õèÔ∏è</text></svg>'), auto";
            } else {
                btn.classList.remove('selected');
                canvas.style.cursor = "crosshair";
            }
        }

        function gameLoop(timestamp) {
            if (gameState.paused) return;
            const dt = Math.min((timestamp - lastTime) / 1000, 0.1); 
            lastTime = timestamp;
            const timeFactor = (dt * 60) * GAME_SPEED_SCALE;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            updateLogic(timeFactor);
            drawScene();

            if (!gameState.isGameOver && !gameState.isLevelClear) {
                gameLoopId = requestAnimationFrame(gameLoop);
            }
        }

        function updateLogic(timeFactor) {
            globalTimer += timeFactor;
            const lvl = gameState.currentLevelData;

            for(let key in cooldowns) if(cooldowns[key] > 0) cooldowns[key] = Math.max(0, cooldowns[key] - timeFactor);
            if (globalTimer % 200 < timeFactor) spawnSun(Math.random() * (canvas.width - 200) + 100, -50, 50, true);

            handleZombieSpawning(lvl, timeFactor);

            mowers.forEach(m => {
                if (m.active) {
                    m.x += 15 * timeFactor; m.angle += 0.5 * timeFactor;
                    
                    if (m.x > canvas.width) {
                        m.active = false;
                    }

                    zombies.forEach(z => {
                        if (z.row === m.row && Math.abs(z.x - m.x) < 50 && z.health > 0) {
                            z.health = 0; 
                            createParticles(z.x + 50, z.y + 50, '#9c27b0', 15); 
                        }
                    });
                }
            });

            plants.forEach((p, index) => {
                p.timer += timeFactor;
                if (p.type === 'sunflower' && p.timer >= 600) {
                    spawnSun(p.x + CELL_SIZE/2, p.y + CELL_SIZE/2, 25, false);
                    p.timer = 0; p.scale = 1.2; 
                }
                
                if ((p.type === 'peashooter' || p.type === 'snowpea') && p.timer >= 90) {
                    const hasZombie = zombies.some(z => z.row === p.row && z.x > p.x);
                    if (hasZombie) {
                        spawnProjectile(p.x + 60, p.y + 30, p.type);
                        SoundManager.play('shoot'); 
                        p.recoil = 5; p.timer = 0;
                    }
                }

                if (p.isExplosive) {
                    if (p.timer > 60) {
                        createExplosion(p);
                        p.health = 0; 
                    } else {
                        p.opacity = (Math.floor(p.timer / 10) % 2 === 0) ? 1 : 0.5;
                        p.scale = 1 + (p.timer / 60) * 0.5; 
                    }
                }
                
                if (p.scale > 1 && !p.isExplosive) p.scale = Math.max(1, p.scale - 0.02 * timeFactor);
                if (p.recoil > 0) p.recoil = Math.max(0, p.recoil - 0.5 * timeFactor);
            });

            updateProjectiles(timeFactor);
            updateZombies(timeFactor);
            cleanupEntities(timeFactor);
            updateUI();
        }

        // --- ‰øÆÊ≠£: ÂÖ≥Âç°ÁîüÊàêÈÄªËæë ---
        function handleZombieSpawning(lvl, timeFactor) {
            gameState.zombieSpawnTimer -= timeFactor;
            
            let spawnRate = 200;
            if (lvl.mode === 'endless') {
                spawnRate = Math.max(50, 200 - gameState.zombiesKilled * 2);
            } else {
                if (gameState.zombiesSpawned >= lvl.goal && !lvl.mode) {
                    if (zombies.length === 0) levelClear();
                    return;
                }
                spawnRate = 300 - (gameState.zombiesKilled * 5);
            }

            if (gameState.zombieSpawnTimer <= 0) {
                if (lvl.mode === 'boss' && !gameState.bossSpawned && gameState.zombiesKilled >= 5) {
                    spawnZombie('boss');
                    gameState.bossSpawned = true;
                    showMessage("È≠îÂ•≥Â•≥ÁéãÈôç‰∏¥!");
                } 
                // ‰øÆÊ≠£ÔºöÁ°Æ‰øùÂú®BossÊ®°Âºè‰∏ãÔºåBossÊ≤°Âá∫Êù•Ââç‰πü‰ºöÂà∑Â∞èÊÄ™
                else if ((lvl.mode === 'endless') || (lvl.mode === 'boss') || (gameState.zombiesSpawned < lvl.goal)) {
                    const wave = lvl.waves[0]; 
                    const type = pickZombieType(wave);
                    spawnZombie(type);
                    gameState.zombiesSpawned++;
                }
                gameState.zombieSpawnTimer = spawnRate + Math.random() * 50;
            }
            
            if (lvl.mode === 'boss' && gameState.bossSpawned) {
                const bossAlive = zombies.some(z => z.isBoss);
                if (!bossAlive) levelClear();
            }
        }

        function createExplosion(plant) {
            const info = PLANTS_INFO[plant.type];
            let affectedZombies = [];
            
            SoundManager.play('explode'); 
            createParticles(plant.x + 50, plant.y + 50, info.color, 30);
            
            if (plant.type === 'jalapeno') {
                createExplosionVisual(0, plant.row * CELL_SIZE, canvas.width, CELL_SIZE, 'rgba(244, 67, 54, 0.5)');
                affectedZombies = zombies.filter(z => z.row === plant.row);
            } else if (plant.type === 'cherrybomb') {
                const cx = plant.col * CELL_SIZE + GRID_OFFSET_X;
                const cy = plant.row * CELL_SIZE;
                createExplosionVisual(cx - CELL_SIZE, cy - CELL_SIZE, CELL_SIZE*3, CELL_SIZE*3, 'rgba(136, 14, 79, 0.5)');
                
                affectedZombies = zombies.filter(z => {
                    const zCol = Math.floor((z.x - GRID_OFFSET_X) / CELL_SIZE);
                    return Math.abs(z.row - plant.row) <= 1 && Math.abs(zCol - plant.col) <= 1;
                });
            }

            affectedZombies.forEach(z => {
                z.health -= info.damage;
                z.hitEffect = 10;
                createParticles(z.x + 50, z.y + 50, '#000', 5);
            });
        }
        
        let explosionVisuals = [];
        function createExplosionVisual(x, y, w, h, color) {
            explosionVisuals.push({x, y, w, h, color, life: 20});
        }

        function updateProjectiles(timeFactor) {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                let p = projectiles[i];
                p.x += p.speed * timeFactor; 
                let hit = false;
                for (let z of zombies) {
                    if (p.row === z.row && p.x > z.x + 20 && p.x < z.x + 60 && z.health > 0) {
                        z.health -= p.damage;
                        z.hitEffect = 5;
                        SoundManager.play('hit'); 
                        if (p.isSnow && !z.isBoss) { 
                            z.freezeTimer = 180; z.speed = z.baseSpeed * 0.5;
                        }
                        hit = true;
                        createParticles(z.x + 40, z.y + 40, p.isSnow ? '#29b6f6' : '#607d8b', 3);
                        break;
                    }
                }
                if (hit || p.x > canvas.width) projectiles.splice(i, 1);
            }
        }

        function updateZombies(timeFactor) {
            for (let i = zombies.length - 1; i >= 0; i--) {
                let z = zombies[i];
                
                if (z.freezeTimer > 0) {
                    z.freezeTimer -= timeFactor;
                    if (z.freezeTimer <= 0) z.speed = z.baseSpeed;
                } else {
                    z.speed = z.baseSpeed;
                }

                if (!z.isEating) z.x -= z.speed * timeFactor;

                if (z.x < GRID_OFFSET_X - 20) {
                    let mower = mowers[z.row];
                    if (!mower.triggered) {
                        mower.triggered = true; mower.active = true;
                        showMessage("È≠îÊ≥ïÊâ´Â∏öÂêØÂä®!");
                        SoundManager.play('shoot'); 
                    } else if (!mower.active && z.x < -40) {
                        gameOver();
                    }
                }
                
                let eatingPlant = null;
                for (let p of plants) {
                    if (p.row === z.row && z.x < p.x + 50 && z.x > p.x - 20) {
                        eatingPlant = p; break;
                    }
                }
                if (eatingPlant) {
                    z.isEating = true; z.biteTimer += timeFactor;
                    if (z.biteTimer >= 30) {
                        eatingPlant.health -= z.damage; 
                        createParticles(eatingPlant.x + 50, eatingPlant.y + 50, '#8bc34a', 2);
                        z.biteTimer = 0;
                    }
                    if (eatingPlant.health <= 0) z.isEating = false;
                } else {
                    z.isEating = false;
                }
                
                if (z.hitEffect > 0) z.hitEffect -= timeFactor;

                if (z.health <= 0) {
                    killZombie(z);
                    zombies.splice(i, 1);
                }
            }
        }

        function killZombie(z, forceParticle) {
            gameState.zombiesKilled++;
            if (gameState.currentLevelData.mode === 'endless') gameState.score += 100;
            createParticles(z.x + 50, z.y + 50, '#555', 10);
        }

        function cleanupEntities(timeFactor) {
            for (let i = plants.length - 1; i >= 0; i--) if (plants[i].health <= 0) plants.splice(i, 1);
            for (let i = sunItems.length - 1; i >= 0; i--) {
                let s = sunItems[i];
                if (s.isFalling && s.y < s.targetY) s.y += 2 * timeFactor;
                s.lifeTime += timeFactor;
                if (s.lifeTime > 800) sunItems.splice(i, 1);
            }
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx * timeFactor; p.y += p.vy * timeFactor; p.life -= timeFactor;
                if(p.life <= 0) particles.splice(i, 1);
            }
            for (let i = explosionVisuals.length - 1; i >= 0; i--) {
                explosionVisuals[i].life -= timeFactor;
                if(explosionVisuals[i].life <= 0) explosionVisuals.splice(i, 1);
            }
        }

        function drawScene() {
            drawBackground();
            
            explosionVisuals.forEach(e => {
                ctx.fillStyle = e.color;
                ctx.fillRect(e.x, e.y, e.w, e.h);
            });

            mowers.forEach(m => {
                if (!m.triggered || m.x < canvas.width) drawFancyBroom(m.x + 5, m.row * CELL_SIZE + 50, m.angle || 0);
            });

            plants.forEach(p => {
                const cx = p.x + CELL_SIZE/2 + GRID_OFFSET_X;
                const cy = p.y + CELL_SIZE/2;
                
                drawShadow(cx, cy + 35);
                ctx.save(); ctx.translate(cx, cy);
                if (p.recoil) ctx.translate(-p.recoil, 0); 
                if (p.scale) ctx.scale(p.scale, p.scale);
                
                ctx.font = "60px Arial"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                ctx.globalAlpha = p.opacity || 1.0;
                ctx.strokeStyle = "white"; ctx.lineWidth = 4; ctx.strokeText(p.icon, 0, 5); 
                ctx.fillStyle = "white"; ctx.fillText(p.icon, 0, 5);
                
                if (p.type === 'wallnut') {
                    if (p.health < 600) ctx.fillText("ü§ï", 0, 0); 
                    else if (p.health < 1300) ctx.fillText("ü©π", 15, -15);
                }
                ctx.restore();
                if (p.health < PLANTS_INFO[p.type].health && !p.isExplosive) 
                    drawHealthBar(p.x + GRID_OFFSET_X + 10, p.y + 10, 80, p.health, PLANTS_INFO[p.type].health);
            });

            zombies.forEach(z => {
                const cx = z.x + GRID_OFFSET_X;
                const cy = z.y;
                drawShadow(cx + 50, cy + 90, z.scale);
                drawRefinedWitch(cx, cy, z);
                if (z.isBoss) drawHealthBar(cx - 20, cy - 20, 140, z.health, ZOMBIES_INFO.boss.hp, true);
                else drawHealthBar(cx + 15, cy, 70, z.health, ZOMBIES_INFO[z.type].hp);
            });

            projectiles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(p.x + GRID_OFFSET_X, p.y + CELL_SIZE/2, 12, 0, Math.PI * 2); ctx.fill();
                if (p.isSnow) { ctx.strokeStyle = "rgba(255,255,255,0.5)"; ctx.lineWidth = 2; ctx.stroke(); }
            });

            // --- ‰øÆÊ≠£: Èò≥ÂÖâÁªòÂà∂ÔºåÂ¢ûÂä†ÈªÑËâ≤ÂúÜÂ∫ïÔºåÈò≤Ê≠¢ÈÄèÊòé ---
            ctx.globalAlpha = 1.0; // Á°Æ‰øù‰∏çË¢´Ê§çÁâ©ÂΩ±Âìç
            sunItems.forEach(s => {
                ctx.save(); ctx.translate(s.x, s.y); ctx.rotate(globalTimer * 0.02);
                
                // ÁªòÂà∂ËÉåÊôØÂÖâÊôïÂúÜ
                ctx.beginPath();
                ctx.arc(0, 0, 25, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(255, 235, 59, 0.9)"; // Êòé‰∫ÆÁöÑÈªÑËâ≤Â∫ï
                ctx.fill();
                ctx.strokeStyle = "orange";
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.shadowBlur = 15; ctx.shadowColor = "yellow";
                ctx.font = "40px Arial"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                ctx.fillStyle = "white"; // Á°Æ‰øùÊñáÂ≠óÊúâÈ¢úËâ≤
                ctx.fillText("‚òÄÔ∏è", 0, 2); 
                ctx.restore();
            });

            particles.forEach(p => {
                ctx.globalAlpha = Math.max(0, p.life / 20); ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(p.x + GRID_OFFSET_X, p.y, p.size, 0, Math.PI*2); ctx.fill();
                ctx.globalAlpha = 1;
            });
        }

        function drawBackground() {
            ctx.fillStyle = "#5d4037"; ctx.fillRect(0, 0, GRID_OFFSET_X, canvas.height);
            ctx.fillStyle = "#3e2723"; ctx.fillRect(GRID_OFFSET_X - 4, 0, 4, canvas.height);
            ctx.strokeStyle = "rgba(0,0,0,0.1)"; ctx.lineWidth = 1;
            for (let row = 0; row < GRID_ROWS; row++) {
                for (let col = 0; col < GRID_COLS; col++) {
                    ctx.strokeRect(col * CELL_SIZE + GRID_OFFSET_X, row * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }
            }
        }
        function drawShadow(x, y, scale = 1) {
            ctx.fillStyle = "rgba(0,0,0,0.2)";
            ctx.beginPath(); ctx.ellipse(x, y, 30 * scale, 8 * scale, 0, 0, Math.PI * 2); ctx.fill();
        }
        function drawFancyBroom(x, y, angle) {
            ctx.save(); ctx.translate(x, y); if (angle) ctx.rotate(angle);
            const hover = Math.sin(globalTimer * 0.1) * 3; ctx.translate(0, hover);
            ctx.shadowBlur = 15; ctx.shadowColor = "#e040fb";
            const grad = ctx.createLinearGradient(0, 30, 40, -10); grad.addColorStop(0, '#5d4037'); grad.addColorStop(1, '#8d6e63');
            ctx.strokeStyle = grad; ctx.lineWidth = 8; ctx.lineCap = "round";
            ctx.beginPath(); ctx.moveTo(0, 20); ctx.lineTo(50, -20); ctx.stroke();
            ctx.fillStyle = "#ffb74d"; ctx.beginPath(); ctx.moveTo(0, 20); ctx.quadraticCurveTo(-15, 30, -20, 45); ctx.lineTo(10, 50); ctx.lineTo(15, 10); ctx.fill();
            ctx.strokeStyle = "#d50000"; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(0, 20); ctx.lineTo(12, 12); ctx.stroke();
            ctx.fillStyle = "#f50057"; ctx.beginPath(); ctx.arc(25, 0, 6, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = "white"; ctx.beginPath(); ctx.arc(23, -2, 2, 0, Math.PI*2); ctx.fill(); 
            ctx.restore();
        }
        function drawRefinedWitch(x, y, zombie) {
            const size = CELL_SIZE; const cx = x + size/2; const cy = y + size/2;
            const breathe = Math.sin(globalTimer * 0.05) * 2;
            const walkWobble = Math.sin(globalTimer * 0.2) * 5;
            
            ctx.save(); ctx.translate(cx, cy + breathe);
            
            if (zombie.scale !== 1) ctx.scale(zombie.scale, zombie.scale);

            if (zombie.isEating) {
                const bite = Math.sin(globalTimer * 0.5) * 5;
                ctx.rotate(bite * 0.05); ctx.translate(bite, 0);
            } else {
                ctx.rotate(walkWobble * 0.02);
            }
            if (zombie.hitEffect > 0) { ctx.globalCompositeOperation = 'overlay'; ctx.fillStyle = 'white'; }
            if (zombie.freezeTimer > 0) ctx.filter = 'hue-rotate(180deg) brightness(1.2)';

            ctx.fillStyle = '#7e57c2'; ctx.beginPath(); ctx.arc(0, -5, 30, 0, Math.PI * 2); ctx.fill(); 
            ctx.fillStyle = zombie.hat === 'rusher' ? '#b71c1c' : '#311b92'; 
            if (zombie.isBoss) ctx.fillStyle = '#4a148c'; 
            ctx.beginPath(); ctx.moveTo(-15, 10); ctx.lineTo(15, 10); ctx.lineTo(20, 45); ctx.quadraticCurveTo(0, 50, -20, 45); ctx.fill(); 

            ctx.fillStyle = '#e91e63'; ctx.beginPath(); ctx.arc(0, 15, 5, 0, Math.PI*2); ctx.fill(); 
            ctx.fillStyle = '#c5e1a5'; ctx.beginPath(); ctx.ellipse(0, -10, 22, 20, 0, 0, Math.PI*2); ctx.fill(); 
            let eyeOpen = 3; if (globalTimer % 120 > 110) eyeOpen = 0.5;
            ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.ellipse(-8, -10, 6, eyeOpen+2, 0, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = zombie.hat === 'giant' ? '#d50000' : '#f44336'; ctx.beginPath(); ctx.arc(-8, -10, 2, 0, Math.PI*2); ctx.fill(); 
            ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.ellipse(8, -10, 6, eyeOpen+2, 0, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#2196f3'; ctx.beginPath(); ctx.arc(8, -10, 2, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = 'rgba(233, 30, 99, 0.3)';
            ctx.beginPath(); ctx.arc(-12, -2, 4, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(12, -2, 4, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = '#558b2f'; ctx.lineWidth = 2; ctx.beginPath();
            if (zombie.isEating) { ctx.arc(0, 2, 5, 0, Math.PI*2); } else { ctx.moveTo(-5, 5); ctx.lineTo(5, 5); }
            ctx.stroke();

            ctx.save(); ctx.rotate(Math.sin(globalTimer * 0.1) * 0.1);
            if (zombie.hat === 'cone') {
                ctx.fillStyle = '#ff9800'; ctx.beginPath(); ctx.moveTo(-15, -25); ctx.lineTo(15, -25); ctx.lineTo(0, -65); ctx.fill();
            } else if (zombie.hat === 'bucket') {
                ctx.fillStyle = '#bdbdbd'; ctx.beginPath(); ctx.moveTo(-16, -25); ctx.lineTo(16, -25); ctx.lineTo(14, -55); ctx.lineTo(-14, -55); ctx.fill();
                ctx.strokeStyle = '#757575'; ctx.lineWidth = 2; ctx.strokeRect(-16, -55, 32, 5);
            } else if (zombie.hat === 'rusher') {
                ctx.fillStyle = '#d32f2f'; ctx.beginPath(); ctx.arc(0, -30, 28, Math.PI, 0); ctx.fill();
                ctx.fillStyle = '#fff'; ctx.fillRect(-2, -58, 4, 30); ctx.fillRect(-15, -45, 30, 4);
            } else if (zombie.hat === 'giant') {
                ctx.fillStyle = '#212121'; ctx.beginPath(); ctx.rect(-20, -50, 40, 20); ctx.fill();
            } else if (zombie.hat === 'crown') {
                ctx.fillStyle = '#ffd700'; ctx.beginPath(); 
                ctx.moveTo(-20, -30); ctx.lineTo(-10, -60); ctx.lineTo(0, -40); ctx.lineTo(10, -60); ctx.lineTo(20, -30); 
                ctx.fill();
                ctx.strokeStyle='#daa520'; ctx.stroke();
            } else {
                ctx.fillStyle = '#212121'; ctx.beginPath(); ctx.ellipse(0, -28, 30, 6, 0, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.moveTo(-15, -28); ctx.lineTo(15, -28); ctx.quadraticCurveTo(10, -60, 20, -70);
                ctx.lineTo(-5, -60); ctx.fill(); ctx.strokeStyle = '#9c27b0'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(-14, -30); ctx.lineTo(14, -30); ctx.stroke();
            }
            ctx.restore(); ctx.restore(); ctx.filter = 'none';
        }

        function drawHealthBar(x, y, w, current, max, isBoss = false) {
            ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.fillRect(x, y, w, isBoss ? 10 : 6);
            let color = "#76ff03"; let pct = current/max;
            if (pct < 0.5) color = "#ffeb3b"; if (pct < 0.25) color = "#ff1744";
            if (isBoss) color = "#e040fb"; 
            ctx.fillStyle = color; ctx.fillRect(x+1, y+1, (w-2) * Math.max(0, pct), isBoss ? 8 : 4);
            if (isBoss) { 
                ctx.fillStyle = "white"; ctx.font = "10px Arial"; ctx.fillText(Math.floor(current), x + w/2 - 10, y + 8);
            }
        }

        function selectPlant(type) {
            SoundManager.init(); 
            SoundManager.play('click');
            if (cooldowns[type] > 0) { showMessage("ÂÜ∑Âç¥‰∏≠..."); return; }
            toggleShovel(false); 
            const info = PLANTS_INFO[type];
            if (gameState.sun >= info.cost) {
                if (selectedPlant === type) { selectedPlant = null; highlightCard(null); } 
                else { selectedPlant = type; highlightCard(type); }
            } else { showMessage("Èò≥ÂÖâ‰∏çË∂≥!"); }
        }

        function handleInput(e) {
            if (e.type === 'touchstart') e.preventDefault();
            SoundManager.init(); 
            
            if (gameState.isGameOver || gameState.isLevelClear) return;
            
            let clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
            let clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const clickX = (clientX - rect.left) * scaleX;
            const clickY = (clientY - rect.top) * scaleY;

            for (let i = sunItems.length - 1; i >= 0; i--) {
                let s = sunItems[i]; 
                let dx = clickX - s.x; let dy = clickY - s.y;
                if (dx*dx + dy*dy < 2500) { 
                    gameState.sun += s.value; sunItems.splice(i, 1);
                    SoundManager.play('sun'); 
                    createParticles(s.x, s.y, 'yellow', 5); updateUI(); return; 
                }
            }

            if (clickX < GRID_OFFSET_X) return; 
            const gridX = clickX - GRID_OFFSET_X;
            const col = Math.floor(gridX / CELL_SIZE); 
            const row = Math.floor(clickY / CELL_SIZE);

            if (col >= 0 && col < GRID_COLS && row >= 0 && row < GRID_ROWS) {
                const existingPlantIndex = plants.findIndex(p => p.col === col && p.row === row);
                
                if (gameState.shovelMode) {
                    if (existingPlantIndex !== -1) {
                        plants.splice(existingPlantIndex, 1);
                        SoundManager.play('plant'); 
                        createParticles(clickX, clickY, '#795548', 8);
                        toggleShovel(false); 
                    }
                    return;
                }

                if (selectedPlant) {
                    if (existingPlantIndex === -1) {
                        const info = PLANTS_INFO[selectedPlant];
                        gameState.sun -= info.cost; cooldowns[selectedPlant] = info.cooldown;
                        plants.push({
                            type: selectedPlant, col: col, row: row, x: col * CELL_SIZE, y: row * CELL_SIZE,
                            health: info.health, timer: 0, icon: info.icon, scale: 1, recoil: 0, 
                            isExplosive: info.instant || false
                        });
                        SoundManager.play('plant'); 
                        createParticles(clickX, clickY, '#4caf50', 8);
                        selectedPlant = null; highlightCard(null); updateUI();
                    } else { showMessage("ËøôÈáåÂ∑≤ÊúâÊ§çÁâ©!"); }
                }
            }
        }

        function pickZombieType(allowedTypes) {
            return allowedTypes[Math.floor(Math.random() * allowedTypes.length)];
        }
        function spawnSun(x, y, value, isFalling) {
            sunItems.push({ x, y, targetY: isFalling ? Math.random() * (canvas.height - 100) + 100 : y, value, isFalling, lifeTime: 0 });
        }
        function spawnZombie(type) {
            const row = Math.floor(Math.random() * GRID_ROWS);
            const info = ZOMBIES_INFO[type];
            zombies.push({ 
                type, row, x: canvas.width, y: row * CELL_SIZE, 
                health: info.hp, maxHp: info.hp, speed: info.speed + Math.random()*0.1, baseSpeed: info.speed, hat: info.hat,
                isEating: false, biteTimer: 0, hitEffect: 0, freezeTimer: 0, scale: info.scale || 1, damage: info.damage, isBoss: info.isBoss
            });
        }
        function spawnProjectile(x, y, plantType) {
            const row = Math.floor(y / CELL_SIZE);
            const isSnow = plantType === 'snowpea';
            projectiles.push({ x, y, row, speed: 7, damage: 20, isSnow, color: isSnow ? '#29b6f6' : '#8bc34a' });
        }
        function createParticles(x, y, color, count) {
            for(let i=0; i<count; i++) particles.push({ x, y, vx: (Math.random()-0.5)*6, vy: (Math.random()-0.5)*6, life: 30+Math.random()*10, color, size: Math.random()*5+2 });
        }
        function highlightCard(type) {
            document.querySelectorAll('.card').forEach(c => c.classList.remove('selected'));
            if (type) document.getElementById(`card-${type}`).classList.add('selected');
        }
        function updateUI() {
            document.getElementById('sun-count').innerText = gameState.sun;
            const lvl = gameState.currentLevelData;
            let progress = 0;
            if (lvl.mode === 'endless') progress = 100; 
            else if (lvl.mode === 'boss') progress = gameState.bossSpawned ? 100 : (gameState.zombiesKilled / 5) * 50; 
            else progress = Math.min(100, (gameState.zombiesKilled / lvl.goal) * 100);
            
            document.getElementById('progress-bar').style.width = `${progress}%`;
            
            document.querySelectorAll('.card').forEach(card => {
                const id = card.id.replace('card-', '');
                const cost = parseInt(card.querySelector('.card-cost').innerText);
                const mask = card.querySelector('.cooldown-mask');
                if (cooldowns[id] > 0) {
                    mask.style.height = `${(cooldowns[id] / PLANTS_INFO[id].cooldown) * 100}%`;
                    card.classList.add('disabled');
                } else {
                    mask.style.height = '0%';
                    if (gameState.sun < cost) card.classList.add('disabled'); else card.classList.remove('disabled');
                }
            });
        }
        function showMessage(text) {
            const msg = document.getElementById('message');
            msg.innerText = text; msg.style.opacity = 1; msg.style.top = "40%";
            setTimeout(() => { msg.style.opacity = 0; msg.style.top = "30%"; }, 1500);
        }
        function levelClear() {
            gameState.isLevelClear = true; gameState.paused = true;
            SoundManager.play('win'); 
            const msg = gameState.currentLevelData.mode === 'endless' ? "Êó†Â∞ΩÊåëÊàòÁªìÊùü" : "ÂÖ≥Âç°ÂÆåÊàê!";
            document.getElementById('level-clear-msg').innerText = msg;
            document.getElementById('btn-next-level').style.display = gameState.currentLevelData.mode === 'endless' ? 'none' : 'block';
            document.getElementById('level-clear-screen').style.display = 'flex';
        }
        function gameOver() {
            gameState.isGameOver = true; gameState.paused = true;
            SoundManager.play('lose'); 
            document.getElementById('game-over-screen').style.display = 'flex';
        }
    </script>
</body>
</html>
